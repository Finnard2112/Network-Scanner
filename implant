#!/usr/bin/env python3

import struct
import netifaces
from netaddr import *
import socket
import time
import binascii

interfaces = netifaces.interfaces()
hosts = {}

for interface in interfaces:
    if interface != 'lo' and interface != 'eth1':
        hosts[interface] = []
        sock = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))
        sock.settimeout(1.0)
        sock.bind((interface,0))
        # Getting the interfaces on the current computer
        addrs = netifaces.ifaddresses(interface)
        # Getting the first address of the returned list (assuming no multiple address in an interface)
        MAC_addr = addrs[netifaces.AF_LINK][0]
        IP4_addr = addrs[netifaces.AF_INET][0]
        # Getting the Network IP.
        my_ip = IPAddress(IP4_addr['addr'])
        netmask = IPAddress(IP4_addr['netmask'])
        network_ip = IPAddress((int(my_ip) & int(netmask)))
        # Convert network IPAddress to IPNetwork
        network_ip = IPNetwork(network_ip)
        network_ip.netmask = netmask

        # Destination is Broadcast
        ethernet_header = bytes.fromhex('ff:ff:ff:ff:ff:ff'.replace(":", ""))
        # Source is current MAC addr
        ethernet_header += bytes.fromhex(MAC_addr['addr'].replace(":", ""))
        ethernet_header += b'\x08\x06' # ARP Protocol

        arp_header = b'\x00\x01\x08\x00\x06\x04' # Hardware/Protocol type/length

        # Iterate over every usable IP address in current subnet
        cur_ip = IPAddress(int(network_ip.ip) + 1)
        while cur_ip != network_ip.broadcast:
            arp_data = arp_header + b'\x00\x01' # Request opcode
            arp_data += bytes.fromhex(MAC_addr['addr'].replace(":", "")) # Source MAC addr
            arp_data += socket.inet_aton(str(my_ip)) # Source IP
            arp_data += b'\x00\x00\x00\x00\x00\x00' # Zeroed out in a request
            arp_data += socket.inet_aton(str(cur_ip)) # Requested IP address
            print("\nRequested IP: " + str(cur_ip))
            print("\Requested IP in bytes: ")
            print(socket.inet_aton(str(cur_ip)))
            print("\nARP Packet: ")
            print(arp_data)

            frame = ethernet_header + arp_data # The entire ethernet frame

            sock.send(frame) # send the frame
            
            try: # try to receive a response immediately. The timeout is 1 second
                received = 0
                while received < 3:
                    response = sock.recv(4096)
                    header = struct.unpack("!6s6sH", response[0:14])
                    if header[2] == 0x0806: # The protocol is ARP
                        print ("SUCCESSFULLY RECEIVED A RESPONSE")
                        *_, sha, spa, tha, tpa = struct.unpack('2s2s1s1s2s6s4s6s4s', response[14:42])
                        sha = ':'.join(format(byte, '02x') for byte in sha)
                        tha = ':'.join(format(byte, '02x') for byte in tha)
                        spa = socket.inet_ntoa(spa)
                        tpa = socket.inet_ntoa(tpa)
                        print("Host discovered. MAC Address: " + sha + ". IP address: " + tpa)
                        break
                    received += 1
                if received == 3:
                    print("Didn't receive an ARP response within 3 packets")
            except socket.timeout:
                print("Timed out waiting for data")
            except Exception as e:
                print(f"An error occurred when trying to recv (not timeout): {e}")
                print("continuing to scan for other IPs")

            cur_ip = IPAddress(int(cur_ip) + 1)
        sock.close()
